# mishka_ai/handlers/admin_commands/memory_commands.py
import logging
import json 
import asyncio 
from datetime import datetime, timezone, timedelta 
from telegram import Update, constants, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.helpers import escape_markdown
import numpy as np 

from mishka_ai.memory_manager import MemoryManager, DEFAULT_IMPORTANCE_SCORE 

logger = logging.getLogger(__name__)

FACTS_PER_PAGE = 5 

# --- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ---
def _get_facts_pagination_keyboard(current_page: int, total_pages: int) -> InlineKeyboardMarkup:
    buttons = []
    row = []
    if current_page > 1:
        row.append(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"facts_page_{current_page - 1}"))
    
    row.append(InlineKeyboardButton(f"üìÑ {current_page}/{total_pages}", callback_data="facts_page_ignore"))

    if current_page < total_pages:
        row.append(InlineKeyboardButton("–í–ø–µ—Ä–µ–¥ ‚û°Ô∏è", callback_data=f"facts_page_{current_page + 1}"))
    
    if row: buttons.append(row)
    return InlineKeyboardMarkup(buttons)

async def _format_facts_for_page(
    memory_manager: MemoryManager, 
    sorted_fact_items: list[dict], 
    page: int,
    users_data: dict
    ) -> str:
    
    start_index = (page - 1) * FACTS_PER_PAGE
    end_index = start_index + FACTS_PER_PAGE
    page_fact_items = sorted_fact_items[start_index:end_index]

    if not page_fact_items: return "–ù–∞ —ç—Ç–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ —Ñ–∞–∫—Ç–æ–≤ –Ω–µ—Ç."
    
    page_text_parts = []
    for fact_item in page_fact_items: 
        fact_id = fact_item['id']
        meta = fact_item.get('meta', {}) 
        
        fact_text_content = meta.get("text_original", f"N/A (text_original –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è ID: {fact_id})")
        escaped_fact_text = escape_markdown(fact_text_content) 
        
        ts_added_str = meta.get("timestamp_added", "N/A")
        ts_last_accessed_str = meta.get("last_accessed_timestamp", "N/A")
        access_count = meta.get("access_count", 0)
        importance = meta.get("importance_score", 0.0)

        user_ids_json_str = meta.get("user_ids_json", "[]")
        user_ids_list = []
        try: user_ids_list = json.loads(user_ids_json_str)
        except json.JSONDecodeError: logger.warning(f"_format_facts_for_page: –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π JSON –¥–ª—è user_ids –≤ —Ñ–∞–∫—Ç–µ {fact_id}: {user_ids_json_str}")

        user_names_to_display = []
        if user_ids_list:
            for uid in user_ids_list:
                if uid in users_data:
                    user_names_to_display.append(users_data[uid].get('name', f'User_{uid}'))
                else:
                    user_names_to_display.append(f'{uid} (–Ω–µ–∏–∑–≤.)')
        
        user_info_str = f" (–ü–æ–ª—å–∑: {escape_markdown(', '.join(user_names_to_display))})" if user_names_to_display else ""
        
        # --- –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï –ó–î–ï–°–¨: \\n –∑–∞–º–µ–Ω–µ–Ω –Ω–∞ \n ---
        entry = f"\nüìù *–§–∞–∫—Ç ID:* `{fact_id}`\n"
        entry += f"   –¢–µ–∫—Å—Ç: _{escaped_fact_text}_ {user_info_str}\n" 
        entry += f"   –î–æ–±–∞–≤–ª–µ–Ω: {escape_markdown(ts_added_str[:19])}\n" 
        entry += f"   –î–æ—Å—Ç—É–ø: {escape_markdown(ts_last_accessed_str[:19])} (x{access_count}) –í–∞–∂–Ω–æ—Å—Ç—å: {importance:.2f}\n"
        page_text_parts.append(entry)
        
    return "".join(page_text_parts)

def _calculate_cosine_similarity(vec1: list[float], vec2: list[float]) -> float:
    if vec1 is None or vec2 is None: 
        return 0.0
    
    if not isinstance(vec1, (list, np.ndarray)) or not isinstance(vec2, (list, np.ndarray)):
        logger.warning(f"–ü–æ–ø—ã—Ç–∫–∞ —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å —Å—Ö–æ–¥—Å—Ç–≤–æ –¥–ª—è –Ω–µ-—Å–ø–∏—Å–∫–æ–≤/–º–∞—Å—Å–∏–≤–æ–≤: {type(vec1)}, {type(vec2)}")
        return 0.0
    
    if isinstance(vec1, list) and not vec1: return 0.0
    if isinstance(vec2, list) and not vec2: return 0.0
    if isinstance(vec1, np.ndarray) and vec1.size == 0: return 0.0
    if isinstance(vec2, np.ndarray) and vec2.size == 0: return 0.0

    vec1_np = np.array(vec1, dtype=np.float32)
    vec2_np = np.array(vec2, dtype=np.float32)
    
    if vec1_np.size == 0 or vec2_np.size == 0: 
        return 0.0

    dot_product = np.dot(vec1_np, vec2_np)
    norm_vec1 = np.linalg.norm(vec1_np)
    norm_vec2 = np.linalg.norm(vec2_np)
    
    if norm_vec1 == 0 or norm_vec2 == 0:
        return 0.0
        
    similarity = dot_product / (norm_vec1 * norm_vec2)
    return float(similarity)


# --- –ö–æ–º–∞–Ω–¥—ã ---
async def memory_stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id_str = str(update.effective_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await update.message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –±–æ—Ç–∞.")
        return

    memory_manager: MemoryManager = context.bot_data.get("memory_manager") 
    users_data: dict = context.bot_data.get("users_data_dict", {})
    
    short_term_memory_len = len(context.bot_data.get("short_term_memory").history) if context.bot_data.get("short_term_memory") else 0
    num_known_users = len(users_data)
    num_ltm_facts = memory_manager.count_ltm_facts() if memory_manager else "–û—à–∏–±–∫–∞"
    
    num_emotional_records = 0
    if memory_manager and memory_manager.emotional_memory_handler:
        num_emotional_records = len(memory_manager.emotional_memory_handler.emotional_memory)

    stats_message = "üìä *–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ü–∞–º—è—Ç–∏ –ú–∏—à–∫–∏* üß†\\n\\n"
    stats_message += f"üë• –ò–∑–≤–µ—Å—Ç–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {num_known_users}\\n"
    stats_message += f"üìö –§–∞–∫—Ç–æ–≤ –≤ –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–π –ø–∞–º—è—Ç–∏ (LTM): {num_ltm_facts}\\n"
    stats_message += f"üí¨ –°–æ–æ–±—â–µ–Ω–∏–π –≤ –∫—Ä–∞—Ç–∫–æ—Å—Ä–æ—á–Ω–æ–π –ø–∞–º—è—Ç–∏: {short_term_memory_len}\\n"
    stats_message += f"üé≠ –ó–∞–ø–∏—Å–µ–π –≤ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏: {num_emotional_records}\\n"
    
    await update.message.reply_text(stats_message, parse_mode=constants.ParseMode.MARKDOWN)
    logger.info(f"–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä {update.effective_user.full_name} –∑–∞–ø—Ä–æ—Å–∏–ª —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–∞–º—è—Ç–∏.")

async def list_facts_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id_str = str(update.effective_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await update.message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –±–æ—Ç–∞.")
        return

    memory_manager: MemoryManager = context.bot_data.get("memory_manager") 
    users_data: dict = context.bot_data.get("users_data_dict", {})
    if not memory_manager or not memory_manager.ltm_db or not memory_manager.ltm_db.collection:
        await update.message.reply_text("–î–æ–ª–≥–æ—Å—Ä–æ—á–Ω–∞—è –ø–∞–º—è—Ç—å (LTM) –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞.", parse_mode=constants.ParseMode.MARKDOWN)
        return

    try:
        all_facts_data = memory_manager.get_ltm_data(include=["metadatas"]) 
        
        if not all_facts_data or not all_facts_data.get("ids"):
            await update.message.reply_text("–í –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–π –ø–∞–º—è—Ç–∏ –ø–æ–∫–∞ –Ω–µ—Ç —Ñ–∞–∫—Ç–æ–≤.")
            return
            
        facts_for_sorting = []
        ids_list = all_facts_data.get("ids", []) 
        metadatas_list = all_facts_data.get("metadatas", [])

        for i in range(len(ids_list)):
            fact_id = ids_list[i]
            meta = metadatas_list[i] if i < len(metadatas_list) and metadatas_list[i] is not None else {}
            sort_key_timestamp = meta.get("last_accessed_timestamp", meta.get("timestamp_added", "1970-01-01T00:00:00Z"))
            facts_for_sorting.append({"id": fact_id, "sort_ts": sort_key_timestamp, "meta": meta})

        sorted_fact_items = sorted(facts_for_sorting, key=lambda x: x["sort_ts"], reverse=True)
        
        total_facts = len(sorted_fact_items)
        if total_facts == 0:
            await update.message.reply_text("–í –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–π –ø–∞–º—è—Ç–∏ –ø–æ–∫–∞ –Ω–µ—Ç —Ñ–∞–∫—Ç–æ–≤.")
            return

        total_pages = (total_facts + FACTS_PER_PAGE - 1) // FACTS_PER_PAGE
        current_page = 1

        context.user_data['sorted_ltm_fact_items'] = sorted_fact_items 
        context.user_data['ltm_facts_total_pages'] = total_pages
        
        page_content = await _format_facts_for_page(memory_manager, sorted_fact_items, current_page, users_data)
        
        header = f"üìö *–§–∞–∫—Ç—ã –≤ LTM (–°—Ç—Ä. {current_page}/{total_pages}, –í—Å–µ–≥–æ: {total_facts}, —Å–æ—Ä—Ç. –ø–æ –¥–æ—Å—Ç—É–ø—É/–¥–∞—Ç–µ):*"
        message_text = header + page_content
        reply_markup = _get_facts_pagination_keyboard(current_page, total_pages)
        
        await update.message.reply_text(message_text, reply_markup=reply_markup, parse_mode=constants.ParseMode.MARKDOWN)
        logger.info(f"–ê–¥–º–∏–Ω {update.effective_user.full_name} –∑–∞–ø—Ä–æ—Å–∏–ª —Ñ–∞–∫—Ç—ã LTM (–ø–∞–≥–∏–Ω–∞—Ü–∏—è). –°—Ç—Ä. {current_page}/{total_pages}")

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ list_facts_command: {e}", exc_info=True)
        await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ —Ñ–∞–∫—Ç–æ–≤ LTM.")

async def facts_page_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query; await query.answer() 
    if query.data == "facts_page_ignore": return

    try: requested_page = int(query.data.split("_")[-1])
    except (ValueError, IndexError):
        logger.error(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π callback_data –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ —Ñ–∞–∫—Ç–æ–≤: {query.data}")
        await query.edit_message_text("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—ã.", parse_mode=constants.ParseMode.MARKDOWN); return

    user_id_str = str(query.from_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await query.edit_message_text("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.", parse_mode=constants.ParseMode.MARKDOWN); return

    memory_manager: MemoryManager = context.bot_data.get("memory_manager")
    users_data: dict = context.bot_data.get("users_data_dict", {})
        
    sorted_fact_items = context.user_data.get('sorted_ltm_fact_items') 
    total_pages = context.user_data.get('ltm_facts_total_pages') 

    if sorted_fact_items is None or total_pages is None:
        await query.edit_message_text("–û—à–∏–±–∫–∞: –î–∞–Ω–Ω—ã–µ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ LTM —Ñ–∞–∫—Ç–æ–≤ —É—Å—Ç–∞—Ä–µ–ª–∏. /list_facts —Å–Ω–æ–≤–∞.", parse_mode=constants.ParseMode.MARKDOWN); return

    if not (1 <= requested_page <= total_pages):
        logger.warning(f"–ó–∞–ø—Ä–æ—à–µ–Ω–∞ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ LTM —Ñ–∞–∫—Ç–æ–≤ {requested_page} –∏–∑ {total_pages}.")
        await query.answer("–ó–∞–ø—Ä–æ—à–µ–Ω–∞ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞."); return
        
    current_page = requested_page
    try:
        page_content = await _format_facts_for_page(memory_manager, sorted_fact_items, current_page, users_data)
        total_facts = len(sorted_fact_items)
        header = f"üìö *–§–∞–∫—Ç—ã –≤ LTM (–°—Ç—Ä. {current_page}/{total_pages}, –í—Å–µ–≥–æ: {total_facts}, —Å–æ—Ä—Ç. –ø–æ –¥–æ—Å—Ç—É–ø—É/–¥–∞—Ç–µ):*"
        message_text = header + page_content
        reply_markup = _get_facts_pagination_keyboard(current_page, total_pages)
        
        if query.message and (query.message.text != message_text or query.message.reply_markup != reply_markup) :
            await query.edit_message_text(text=message_text, reply_markup=reply_markup, parse_mode=constants.ParseMode.MARKDOWN)
        else: logger.info(f"–¢–µ–∫—Å—Ç –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã {current_page} LTM —Ñ–∞–∫—Ç–æ–≤ –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å.")
        logger.info(f"–ê–¥–º–∏–Ω {query.from_user.full_name} –ø–µ—Ä–µ–∫–ª—é—á–∏–ª —Å—Ç—Ä–∞–Ω–∏—Ü—É LTM —Ñ–∞–∫—Ç–æ–≤ –Ω–∞ {current_page}/{total_pages}")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å–ø–∏—Å–∫–∞ LTM —Ñ–∞–∫—Ç–æ–≤: {e}", exc_info=True)
        try: await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã LTM —Ñ–∞–∫—Ç–æ–≤.", parse_mode=constants.ParseMode.MARKDOWN)
        except Exception: pass

async def find_facts_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id_str = str(update.effective_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id: await update.message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –±–æ—Ç–∞."); return
    if not context.args: await update.message.reply_text("–£–∫–∞–∂–∏ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞. `/find_facts –≤—Å—Ç—Ä–µ—á–∞ –ª–µ–Ω–∞ –∞–≤–≥—É—Å—Ç`", parse_mode=constants.ParseMode.MARKDOWN); return
    
    query_text = " ".join(context.args)
    memory_manager: MemoryManager = context.bot_data.get("memory_manager")
    if not memory_manager or not memory_manager.yandex_embedder or not memory_manager.ltm_db:
        await update.message.reply_text("–ü–∞–º—è—Ç—å –∏–ª–∏ —ç–º–±–µ–¥–¥–µ—Ä –Ω–µ –≥–æ—Ç–æ–≤—ã –¥–ª—è –ø–æ–∏—Å–∫–∞ —Ñ–∞–∫—Ç–æ–≤.", parse_mode=constants.ParseMode.MARKDOWN); return
    
    max_relevant_distance = context.bot_data.get("LTM_MAX_RELEVANT_DISTANCE_CONFIG", 1.0)

    N_results = 5 
    found_fact_texts = await memory_manager.get_relevant_facts_from_ltm(
        query_text=query_text, 
        N=N_results,
        max_distance=max_relevant_distance
    )

    if not found_fact_texts:
        await update.message.reply_text(f"–ù–µ –Ω–∞–π–¥–µ–Ω–æ —Ñ–∞–∫—Ç–æ–≤, –±–ª–∏–∑–∫–∏—Ö –∫: '{escape_markdown(query_text)}' (—Å –ø–æ—Ä–æ–≥–æ–º –¥–∏—Å—Ç–∞–Ω—Ü–∏–∏ {max_relevant_distance}).", parse_mode=constants.ParseMode.MARKDOWN); return

    response_text = f"üîé *–ù–∞–π–¥–µ–Ω–Ω—ã–µ —Ñ–∞–∫—Ç—ã –ø–æ –∑–∞–ø—Ä–æ—Å—É \\\"{escape_markdown(query_text)}\\\" ({len(found_fact_texts)} —à—Ç.):*\\n\\n"
    for i, fact_text in enumerate(found_fact_texts):
        response_text += f"{i+1}. _{escape_markdown(fact_text)}_\\n\\n" 
    
    if len(response_text) > 4000: 
        await update.message.reply_text("–ù–∞–π–¥–µ–Ω–æ –º–Ω–æ–≥–æ, –ø–æ–∫–∞–∑—ã–≤–∞—é –ø–µ—Ä–≤—ã–µ:\\n" + response_text[:3900] + "\\n...", parse_mode=constants.ParseMode.MARKDOWN)
    else:
        await update.message.reply_text(response_text, parse_mode=constants.ParseMode.MARKDOWN)
    logger.info(f"–ê–¥–º–∏–Ω {update.effective_user.full_name} –∏—Å–∫–∞–ª —Ñ–∞–∫—Ç—ã: '{query_text}'. –ù–∞–π–¥–µ–Ω–æ: {len(found_fact_texts)}")

async def delete_fact_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id_str = str(update.effective_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await update.message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –±–æ—Ç–∞."); return

    if not context.args or len(context.args) != 1:
        await update.message.reply_text("–£–∫–∞–∂–∏ ID —Ñ–∞–∫—Ç–∞. `/delete_fact <ID_—Ñ–∞–∫—Ç–∞>`", parse_mode=constants.ParseMode.MARKDOWN); return

    fact_id_to_delete = context.args[0]
    memory_manager: MemoryManager = context.bot_data.get("memory_manager") 

    if not memory_manager or not memory_manager.ltm_db:
        await update.message.reply_text("–î–æ–ª–≥–æ—Å—Ä–æ—á–Ω–∞—è –ø–∞–º—è—Ç—å LTM –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞.", parse_mode=constants.ParseMode.MARKDOWN); return
    
    try:
        fact_data = memory_manager.get_ltm_data(ids=[fact_id_to_delete], include=["metadatas"])
        fact_text_to_delete = "N/A (—Ç–µ–∫—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ —Ñ–∞–∫—Ç —É–∂–µ —É–¥–∞–ª–µ–Ω)"
        if fact_data and fact_data.get("ids") and fact_data.get("metadatas") and fact_data["metadatas"] and fact_data["metadatas"][0]:
            fact_text_to_delete = fact_data["metadatas"][0].get("text_original", "N/A (—Ç–µ–∫—Å—Ç –Ω–µ –∏–∑–≤–ª–µ—á–µ–Ω –∏–∑ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö)")
        elif fact_data and fact_data.get("ids"):
             logger.warning(f"–§–∞–∫—Ç ID {fact_id_to_delete} –Ω–∞–π–¥–µ–Ω, –Ω–æ —Ç–µ–∫—Å—Ç –Ω–µ –∏–∑–≤–ª–µ—á–µ–Ω –∏–∑ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö. –ú–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ: {fact_data.get('metadatas')}")
        else: 
            await update.message.reply_text(f"–§–∞–∫—Ç ID `{escape_markdown(fact_id_to_delete)}` –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ LTM.", parse_mode=constants.ParseMode.MARKDOWN); return

        success = memory_manager.delete_ltm_facts_by_ids(ids=[fact_id_to_delete])
        
        if success:
            if 'sorted_ltm_fact_items' in context.user_data: del context.user_data['sorted_ltm_fact_items']
            if 'ltm_facts_total_pages' in context.user_data: del context.user_data['ltm_facts_total_pages']
            await update.message.reply_text(f"–§–∞–∫—Ç ID `{escape_markdown(fact_id_to_delete)}` (–¢–µ–∫—Å—Ç: _{escape_markdown(fact_text_to_delete)}_) —É–¥–∞–ª–µ–Ω –∏–∑ LTM. –ü–∞–≥–∏–Ω–∞—Ü–∏—è —Å–±—Ä–æ—à–µ–Ω–∞, /list_facts –∑–∞–Ω–æ–≤–æ.", parse_mode=constants.ParseMode.MARKDOWN)
            logger.info(f"–ê–¥–º–∏–Ω {update.effective_user.full_name} —É–¥–∞–ª–∏–ª —Ñ–∞–∫—Ç ID: {fact_id_to_delete} –∏–∑ LTM.")
        else:
            await update.message.reply_text(f"–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Ñ–∞–∫—Ç ID `{escape_markdown(fact_id_to_delete)}` –∏–∑ LTM (–≤–æ–∑–º–æ–∂–Ω–æ, –æ–Ω —É–∂–µ –±—ã–ª —É–¥–∞–ª–µ–Ω –∏–ª–∏ –æ—à–∏–±–∫–∞ –ë–î).", parse_mode=constants.ParseMode.MARKDOWN)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ñ–∞–∫—Ç–∞ ID {fact_id_to_delete} –∏–∑ LTM: {e}", exc_info=True)
        await update.message.reply_text(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ñ–∞–∫—Ç–∞ –∏–∑ LTM: {e}")

async def clear_ltm_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id_str = str(update.effective_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await update.message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –±–æ—Ç–∞."); return

    keyboard = [[ InlineKeyboardButton("üî¥ –î–∞, –û–ß–ò–°–¢–ò–¢–¨ –í–°–ï –§–ê–ö–¢–´ LTM!", callback_data="confirm_clear_ltm_yes"),
                  InlineKeyboardButton("üü¢ –ù–µ—Ç, –æ—Ç–º–µ–Ω–∞", callback_data="confirm_clear_ltm_no")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "‚ö†Ô∏è *–í–ù–ò–ú–ê–ù–ò–ï!* ‚ö†Ô∏è\\n–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ *–ü–û–õ–ù–û–°–¢–¨–Æ –û–ß–ò–°–¢–ò–¢–¨* –≤—Å—é –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω—É—é –ø–∞–º—è—Ç—å (–≤—Å–µ —Ñ–∞–∫—Ç—ã LTM)?\\n*–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –ù–ï–û–ë–†–ê–¢–ò–ú–û!*",
        reply_markup=reply_markup, parse_mode=constants.ParseMode.MARKDOWN)
    logger.info(f"–ê–¥–º–∏–Ω {update.effective_user.full_name} –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞–ª –æ—á–∏—Å—Ç–∫—É –í–°–ï–• —Ñ–∞–∫—Ç–æ–≤ LTM.")

async def confirm_clear_ltm_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query; await query.answer()
    user_id_str = str(query.from_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await query.edit_message_text("–û–ø–µ—Ä–∞—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.", parse_mode=constants.ParseMode.MARKDOWN); return

    choice = query.data
    memory_manager: MemoryManager = context.bot_data.get("memory_manager")

    if choice == "confirm_clear_ltm_yes":
        if not memory_manager or not memory_manager.ltm_db: 
            await query.edit_message_text("–û—à–∏–±–∫–∞: LTM –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.", parse_mode=constants.ParseMode.MARKDOWN); return
        try:
            logger.warning(f"–ê–¥–º–∏–Ω {query.from_user.full_name} –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª –æ—á–∏—Å—Ç–∫—É –í–°–ï–• —Ñ–∞–∫—Ç–æ–≤ LTM.")
            success = memory_manager.clear_all_ltm_facts()
            if success:
                if 'sorted_ltm_fact_items' in context.user_data: del context.user_data['sorted_ltm_fact_items']
                if 'ltm_facts_total_pages' in context.user_data: del context.user_data['ltm_facts_total_pages']
                logger.info("–ö—ç—à –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ LTM —Ñ–∞–∫—Ç–æ–≤ –æ—á–∏—â–µ–Ω.")
                await query.edit_message_text("‚úÖ –î–æ–ª–≥–æ—Å—Ä–æ—á–Ω–∞—è –ø–∞–º—è—Ç—å (LTM —Ñ–∞–∫—Ç—ã) *–ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—â–µ–Ω–∞*.", parse_mode=constants.ParseMode.MARKDOWN)
                logger.warning(f"LTM —Ñ–∞–∫—Ç—ã –æ—á–∏—â–µ–Ω—ã –∞–¥–º–∏–Ω–æ–º {query.from_user.full_name}.")
            else:
                await query.edit_message_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—Å—Ç–∏—Ç—å LTM —Ñ–∞–∫—Ç—ã. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏.", parse_mode=constants.ParseMode.MARKDOWN)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª–Ω–æ–π –æ—á–∏—Å—Ç–∫–µ LTM —Ñ–∞–∫—Ç–æ–≤: {e}", exc_info=True)
            await query.edit_message_text(f"‚ùå –û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ LTM —Ñ–∞–∫—Ç–æ–≤: {escape_markdown(str(e))}", parse_mode=constants.ParseMode.MARKDOWN)
    elif choice == "confirm_clear_ltm_no":
        await query.edit_message_text("üëå –û—á–∏—Å—Ç–∫–∞ LTM —Ñ–∞–∫—Ç–æ–≤ –æ—Ç–º–µ–Ω–µ–Ω–∞.", parse_mode=constants.ParseMode.MARKDOWN)
        logger.info(f"–ê–¥–º–∏–Ω {query.from_user.full_name} –æ—Ç–º–µ–Ω–∏–ª –æ—á–∏—Å—Ç–∫—É LTM —Ñ–∞–∫—Ç–æ–≤.")
    else:
        await query.edit_message_text("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –≤—ã–±–æ—Ä.", parse_mode=constants.ParseMode.MARKDOWN)

async def clear_emotional_user_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id_str = str(update.effective_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await update.message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –±–æ—Ç–∞.")
        return

    if not context.args:
        await update.message.reply_text(
            "–£–∫–∞–∂–∏—Ç–µ ID, –∏–º—è –∏–ª–∏ –Ω–∏–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, —á—å—é —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—É—é –ø–∞–º—è—Ç—å –Ω—É–∂–Ω–æ –æ—á–∏—Å—Ç–∏—Ç—å.\\n"
            "–ù–∞–ø—Ä–∏–º–µ—Ä: `/clear_emo_user 123456789` –∏–ª–∏ `/clear_emo_user –ì–µ–æ—Ä–≥–∏–π`",
            parse_mode=constants.ParseMode.MARKDOWN
        )
        return

    query_arg = " ".join(context.args).strip()
    users_data: dict = context.bot_data.get("users_data_dict", {})
    memory_manager: MemoryManager = context.bot_data.get("memory_manager")

    if not memory_manager or not memory_manager.emotional_memory_handler:
        await update.message.reply_text("–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.")
        return

    found_user_id_to_clear = None
    found_user_name_to_clear = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"

    for u_id, info in users_data.items():
        name_lower = info.get('name', '').lower()
        nicknames = info.get('nicknames', [])
        if isinstance(nicknames, str): nicknames = [nicknames]
        nicknames_lower = [nick.lower() for nick in nicknames]

        if query_arg == u_id or query_arg.lower() == name_lower or query_arg.lower() in nicknames_lower:
            found_user_id_to_clear = u_id
            found_user_name_to_clear = info.get('name', f"User_{u_id}")
            break
    
    if not found_user_id_to_clear and query_arg.isdigit():
        emo_data_exists = memory_manager.get_emotional_notes(query_arg)
        if emo_data_exists:
             found_user_id_to_clear = query_arg
             found_user_name_to_clear = emo_data_exists.get("name", f"User_{query_arg}")
        
    if not found_user_id_to_clear:
        await update.message.reply_text(f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ –∑–∞–ø—Ä–æ—Å—É '{escape_markdown(query_arg)}' –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è—Ö –∏–ª–∏ –µ–≥–æ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏.")
        return

    keyboard = [[
        InlineKeyboardButton(f"üóëÔ∏è –î–∞, –æ—á–∏—Å—Ç–∏—Ç—å –¥–ª—è {escape_markdown(found_user_name_to_clear)}", callback_data=f"confirm_clear_emo_user_yes_{found_user_id_to_clear}"),
        InlineKeyboardButton("üü¢ –ù–µ—Ç, –æ—Ç–º–µ–Ω–∞", callback_data=f"confirm_clear_emo_user_no_{found_user_id_to_clear}")
    ]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        f"–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ—á–∏—Å—Ç–∏—Ç—å –≤—Å—é —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—É—é –ø–∞–º—è—Ç—å –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è *{escape_markdown(found_user_name_to_clear)}* (ID: `{found_user_id_to_clear}`)?\\n"
        f"–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ.",
        reply_markup=reply_markup,
        parse_mode=constants.ParseMode.MARKDOWN
    )
    logger.info(f"–ê–¥–º–∏–Ω {update.effective_user.full_name} –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞–ª –æ—á–∏—Å—Ç–∫—É —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ID: {found_user_id_to_clear} ({found_user_name_to_clear}).")

async def confirm_clear_emotional_user_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    requesting_admin_id_str = str(query.from_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or requesting_admin_id_str != admin_user_id:
        await query.edit_message_text("–û–ø–µ—Ä–∞—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
        return

    callback_data_parts = query.data.split("_") 
    action = callback_data_parts[-2] 
    user_id_to_clear = callback_data_parts[-1]

    memory_manager: MemoryManager = context.bot_data.get("memory_manager")
    if not memory_manager or not memory_manager.emotional_memory_handler:
        await query.edit_message_text("–û—à–∏–±–∫–∞: –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.")
        return
    
    user_name_display = f"User_{user_id_to_clear}"
    user_data_entry = context.bot_data.get("users_data_dict", {}).get(user_id_to_clear)
    if user_data_entry and user_data_entry.get("name"):
        user_name_display = user_data_entry.get("name")
    else:
        emo_note = memory_manager.get_emotional_notes(user_id_to_clear)
        if emo_note and emo_note.get("name"):
            user_name_display = emo_note.get("name")

    if action == "yes":
        success = memory_manager.clear_user_emotional_data(user_id_to_clear)
        if success:
            await query.edit_message_text(
                f"‚úÖ –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –ø–∞–º—è—Ç—å –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è *{escape_markdown(user_name_display)}* (ID: `{user_id_to_clear}`) *–ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—â–µ–Ω–∞*.",
                parse_mode=constants.ParseMode.MARKDOWN
            )
            logger.warning(f"–≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –ø–∞–º—è—Ç—å –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è {user_id_to_clear} ({user_name_display}) –æ—á–∏—â–µ–Ω–∞ –∞–¥–º–∏–Ω–æ–º {query.from_user.full_name}.")
        else:
            await query.edit_message_text(
                f"‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—á–∏—Å—Ç–∏—Ç—å —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—É—é –ø–∞–º—è—Ç—å –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è *{escape_markdown(user_name_display)}* (ID: `{user_id_to_clear}`). –í–æ–∑–º–æ–∂–Ω–æ, –¥–ª—è –Ω–µ–≥–æ –Ω–µ –±—ã–ª–æ –∑–∞–ø–∏—Å–µ–π.",
                parse_mode=constants.ParseMode.MARKDOWN
            )
    elif action == "no":
        await query.edit_message_text(f"üëå –û—á–∏—Å—Ç–∫–∞ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏ –¥–ª—è *{escape_markdown(user_name_display)}* (ID: `{user_id_to_clear}`) –æ—Ç–º–µ–Ω–µ–Ω–∞.", parse_mode=constants.ParseMode.MARKDOWN)
        logger.info(f"–ê–¥–º–∏–Ω {query.from_user.full_name} –æ—Ç–º–µ–Ω–∏–ª –æ—á–∏—Å—Ç–∫—É —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏ –¥–ª—è {user_id_to_clear}.")
    else:
        await query.edit_message_text("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –≤—ã–±–æ—Ä.")

async def clear_emotional_all_danger_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id_str = str(update.effective_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await update.message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –±–æ—Ç–∞.")
        return

    keyboard = [[
        InlineKeyboardButton("üî¥ –î–∞, –û–ß–ò–°–¢–ò–¢–¨ –í–°–Æ –≠–ú–û–¶. –ü–ê–ú–Ø–¢–¨!", callback_data="confirm_clear_emo_all_yes"),
        InlineKeyboardButton("üü¢ –ù–µ—Ç, –æ—Ç–º–µ–Ω–∞", callback_data="confirm_clear_emo_all_no")
    ]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "‚ö†Ô∏è *–í–ù–ò–ú–ê–ù–ò–ï!* ‚ö†Ô∏è\\n–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ *–ü–û–õ–ù–û–°–¢–¨–Æ –û–ß–ò–°–¢–ò–¢–¨ –í–°–Æ –≠–ú–û–¶–ò–û–ù–ê–õ–¨–ù–£–Æ –ü–ê–ú–Ø–¢–¨* (–¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π)?\\n"
        "*–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –ù–ï–û–ë–†–ê–¢–ò–ú–û!*",
        reply_markup=reply_markup,
        parse_mode=constants.ParseMode.MARKDOWN
    )
    logger.info(f"–ê–¥–º–∏–Ω {update.effective_user.full_name} –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞–ª –æ—á–∏—Å—Ç–∫—É –í–°–ï–ô —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏.")

async def confirm_clear_emotional_all_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    requesting_admin_id_str = str(query.from_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or requesting_admin_id_str != admin_user_id:
        await query.edit_message_text("–û–ø–µ—Ä–∞—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
        return

    choice = query.data 
    memory_manager: MemoryManager = context.bot_data.get("memory_manager")

    if not memory_manager or not memory_manager.emotional_memory_handler:
        await query.edit_message_text("–û—à–∏–±–∫–∞: –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.")
        return

    if choice == "confirm_clear_emo_all_yes":
        try:
            logger.warning(f"–ê–¥–º–∏–Ω {query.from_user.full_name} –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª –æ—á–∏—Å—Ç–∫—É –í–°–ï–ô —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏.")
            success = memory_manager.clear_all_emotional_data()
            if success:
                await query.edit_message_text(
                    "‚úÖ –í—Å—è —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –ø–∞–º—è—Ç—å (–¥–ª—è –≤—Å–µ—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π) *–ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—â–µ–Ω–∞*.",
                    parse_mode=constants.ParseMode.MARKDOWN
                )
                logger.warning(f"–í—Å—è —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –ø–∞–º—è—Ç—å –æ—á–∏—â–µ–Ω–∞ –∞–¥–º–∏–Ω–æ–º {query.from_user.full_name}.")
            else:
                await query.edit_message_text(
                    "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—Å—Ç–∏—Ç—å –≤—Å—é —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—É—é –ø–∞–º—è—Ç—å. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏.",
                    parse_mode=constants.ParseMode.MARKDOWN
                )
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª–Ω–æ–π –æ—á–∏—Å—Ç–∫–µ –≤—Å–µ–π —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏: {e}", exc_info=True)
            await query.edit_message_text(f"‚ùå –û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –≤—Å–µ–π —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏: {escape_markdown(str(e))}", parse_mode=constants.ParseMode.MARKDOWN)
    elif choice == "confirm_clear_emo_all_no":
        await query.edit_message_text("üëå –û—á–∏—Å—Ç–∫–∞ –≤—Å–µ–π —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏ –æ—Ç–º–µ–Ω–µ–Ω–∞.", parse_mode=constants.ParseMode.MARKDOWN)
        logger.info(f"–ê–¥–º–∏–Ω {query.from_user.full_name} –æ—Ç–º–µ–Ω–∏–ª –æ—á–∏—Å—Ç–∫—É –≤—Å–µ–π —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏.")
    else:
        await query.edit_message_text("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –≤—ã–±–æ—Ä.")

async def maintain_ltm_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id_str = str(update.effective_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await update.message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –±–æ—Ç–∞.")
        return

    memory_manager: MemoryManager = context.bot_data.get("memory_manager")
    if not memory_manager or not memory_manager.ltm_db or not memory_manager.yandex_embedder:
        await update.message.reply_text("LTM, –±–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–ª–∏ —ç–º–±–µ–¥–¥–µ—Ä –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã. –û–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ.")
        return

    await update.message.reply_text("‚è≥ –ù–∞—á–∏–Ω–∞—é –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–µ –¥–æ–ª–≥–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–π –ø–∞–º—è—Ç–∏ (LTM)... –≠—Ç–æ –º–æ–∂–µ—Ç –∑–∞–Ω—è—Ç—å –Ω–µ–∫–æ—Ç–æ—Ä–æ–µ –≤—Ä–µ–º—è. –Ø —Å–æ–æ–±—â—É –æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–µ.", 
                                    parse_mode=constants.ParseMode.MARKDOWN)
    
    try:
        args = context.args
        # –°–æ–±–∏—Ä–∞–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è –ø–µ—Ä–µ–¥–∞—á–∏ –≤ MemoryManager
        maintenance_config = {
            "similarity_threshold": float(args[0]) if args and len(args) > 0 else 0.95,
            "max_days_unaccessed": int(args[1]) if args and len(args) > 1 else 90,
            "min_access_for_retention": int(args[2]) if args and len(args) > 2 else 1,
            "importance_decay_factor": context.bot_data.get("LTM_IMPORTANCE_DECAY_FACTOR_CONFIG", 0.02),
            "min_importance_for_retention": context.bot_data.get("LTM_MIN_IMPORTANCE_FOR_RETENTION_CONFIG", 0.5),
            "days_for_decay_check": context.bot_data.get("LTM_DAYS_FOR_IMPORTANCE_DECAY_CONFIG", 14)
        }
        
        logger.info(f"–ê–¥–º–∏–Ω {update.effective_user.full_name} –∑–∞–ø—É—Å—Ç–∏–ª –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–µ LTM —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏: {maintenance_config}")
        
        # –í—ã–∑—ã–≤–∞–µ–º –Ω–æ–≤—ã–π –º–µ—Ç–æ–¥ –∏–∑ MemoryManager
        results = await memory_manager.perform_ltm_maintenance(maintenance_config)

        if results.get("error"):
            await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –≤–æ –≤—Ä–µ–º—è –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è LTM: {results['error']}")
            return
            
        # –û—á–∏—Å—Ç–∫–∞ –∫—ç—à–∞ –ø–∞–≥–∏–Ω–∞—Ü–∏–∏, –µ—Å–ª–∏ —á—Ç–æ-—Ç–æ –∏–∑–º–µ–Ω–∏–ª–æ—Å—å
        if results.get("total_deleted", 0) > 0 or results.get("updated_importance", 0) > 0:
            if 'sorted_ltm_fact_items' in context.user_data: del context.user_data['sorted_ltm_fact_items']
            if 'ltm_facts_total_pages' in context.user_data: del context.user_data['ltm_facts_total_pages']

        # –§–æ—Ä–º–∏—Ä—É–µ–º –∏ –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º –æ—Ç—á–µ—Ç
        deleted_duplicates = results.get("deleted_duplicates", 0)
        deleted_obsolete = results.get("deleted_obsolete", 0)
        total_deleted = results.get("total_deleted", 0)
        updated_importance = results.get("updated_importance", 0)

        if total_deleted == 0 and updated_importance == 0:
            await update.message.reply_text("‚úÖ –û–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–µ LTM –∑–∞–≤–µ—Ä—à–µ–Ω–æ. –§–∞–∫—Ç–æ–≤ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–æ.", parse_mode=constants.ParseMode.MARKDOWN)
        else:
            await update.message.reply_text(
                f"‚úÖ –û–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–µ LTM –∑–∞–≤–µ—Ä—à–µ–Ω–æ.\\n"
                f"- –£–¥–∞–ª–µ–Ω–æ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤/—Å—Ö–æ–∂–∏—Ö: {deleted_duplicates}\\n"
                f"- –£–¥–∞–ª–µ–Ω–æ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö/–Ω–µ–≤–∞–∂–Ω—ã—Ö: {deleted_obsolete}\\n"
                f"- *–í—Å–µ–≥–æ —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö —Ñ–∞–∫—Ç–æ–≤ —É–¥–∞–ª–µ–Ω–æ:* {total_deleted}\\n"
                f"- *–û–±–Ω–æ–≤–ª–µ–Ω–∞ –≤–∞–∂–Ω–æ—Å—Ç—å —É:* {updated_importance} —Ñ–∞–∫—Ç–æ–≤.",
                parse_mode=constants.ParseMode.MARKDOWN
            )

    except Exception as e:
        logger.error(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ —Ö–µ–Ω–¥–ª–µ—Ä–µ maintain_ltm_command: {e}", exc_info=True)
        await update.message.reply_text(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ —Ö–µ–Ω–¥–ª–µ—Ä–µ /maintain_ltm: {escape_markdown(str(e))}", parse_mode=constants.ParseMode.MARKDOWN)