# mishka_ai/handlers/admin_commands/memory_commands.py
import logging
import json 
import asyncio 
from datetime import datetime, timezone, timedelta 
from telegram import Update, constants, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import ContextTypes
from telegram.helpers import escape_markdown
import numpy as np 

from mishka_ai.memory_manager import MemoryManager, DEFAULT_IMPORTANCE_SCORE 

logger = logging.getLogger(__name__)

FACTS_PER_PAGE = 5 

# --- –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ---
def _get_facts_pagination_keyboard(current_page: int, total_pages: int) -> InlineKeyboardMarkup:
    buttons = []
    row = []
    if current_page > 1:
        row.append(InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"facts_page_{current_page - 1}"))
    
    row.append(InlineKeyboardButton(f"üìÑ {current_page}/{total_pages}", callback_data="facts_page_ignore"))

    if current_page < total_pages:
        row.append(InlineKeyboardButton("–í–ø–µ—Ä–µ–¥ ‚û°Ô∏è", callback_data=f"facts_page_{current_page + 1}"))
    
    if row: buttons.append(row)
    return InlineKeyboardMarkup(buttons)

async def _format_facts_for_page(
    memory_manager: MemoryManager, 
    sorted_fact_items: list[dict], 
    page: int,
    users_data: dict
    ) -> str:
    
    start_index = (page - 1) * FACTS_PER_PAGE
    end_index = start_index + FACTS_PER_PAGE
    page_fact_items = sorted_fact_items[start_index:end_index]

    if not page_fact_items: return "\n–ù–∞ —ç—Ç–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü–µ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç."
    
    page_text_parts = []
    for fact_item in page_fact_items: 
        fact_id = fact_item['id']
        meta = fact_item.get('meta', {}) 
        
        fact_text_content = meta.get("text_original", f"N/A (text_original –Ω–µ –Ω–∞–π–¥–µ–Ω –¥–ª—è ID: {fact_id})")
        escaped_fact_text = escape_markdown(fact_text_content) 
        
        ts_added_str = meta.get("timestamp_added", "N/A")
        ts_last_accessed_str = meta.get("last_accessed_timestamp", "N/A")
        access_count = meta.get("access_count", 0)
        importance = meta.get("importance_score", 0.0)

        user_ids_json_str = meta.get("user_ids_json", "[]")
        user_ids_list = []
        try: user_ids_list = json.loads(user_ids_json_str)
        except json.JSONDecodeError: logger.warning(f"_format_facts_for_page: –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π JSON –¥–ª—è user_ids –≤ —Ñ–∞–∫—Ç–µ {fact_id}: {user_ids_json_str}")

        user_names_to_display = []
        if user_ids_list:
            for uid in user_ids_list:
                if uid in users_data:
                    user_names_to_display.append(users_data[uid].get('name', f'User_{uid}'))
                else:
                    user_names_to_display.append(f'{uid} (–Ω–µ–∏–∑–≤.)')
        
        user_info_str = f" (–°—É–±—ä–µ–∫—Ç—ã: {escape_markdown(', '.join(user_names_to_display))})" if user_names_to_display else ""
        
        entry = f"\n*ID –§–∞–∫—Ç–∞:* `{fact_id}`\n"
        entry += f"   *–¢–µ–∫—Å—Ç:* _{escaped_fact_text}_{user_info_str}\n" 
        entry += f"   *–î–æ–±–∞–≤–ª–µ–Ω:* {escape_markdown(ts_added_str[:19])}\n" 
        entry += f"   *–î–æ—Å—Ç—É–ø:* {escape_markdown(ts_last_accessed_str[:19])} (x{access_count}) *–í–∞–∂–Ω–æ—Å—Ç—å:* {importance:.2f}\n"
        page_text_parts.append(entry)
        
    return "".join(page_text_parts)

def _calculate_cosine_similarity(vec1: list[float], vec2: list[float]) -> float:
    if vec1 is None or vec2 is None: 
        return 0.0
    if not isinstance(vec1, (list, np.ndarray)) or not isinstance(vec2, (list, np.ndarray)):
        logger.warning(f"–ü–æ–ø—ã—Ç–∫–∞ —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å —Å—Ö–æ–¥—Å—Ç–≤–æ –¥–ª—è –Ω–µ-—Å–ø–∏—Å–∫–æ–≤/–º–∞—Å—Å–∏–≤–æ–≤: {type(vec1)}, {type(vec2)}")
        return 0.0
    
    vec1_np = np.array(vec1, dtype=np.float32)
    vec2_np = np.array(vec2, dtype=np.float32)
    
    if vec1_np.size == 0 or vec2_np.size == 0: 
        return 0.0

    dot_product = np.dot(vec1_np, vec2_np)
    norm_vec1 = np.linalg.norm(vec1_np)
    norm_vec2 = np.linalg.norm(vec2_np)
    
    if norm_vec1 == 0 or norm_vec2 == 0:
        return 0.0
        
    similarity = dot_product / (norm_vec1 * norm_vec2)
    return float(similarity)


# --- –ö–æ–º–∞–Ω–¥—ã ---
async def memory_stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id_str = str(update.effective_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await update.message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –±–æ—Ç–∞.")
        return

    memory_manager: MemoryManager = context.bot_data.get("memory_manager") 
    users_data: dict = context.bot_data.get("users_data_dict", {})
    
    short_term_memory_len = len(context.bot_data.get("short_term_memory").history) if context.bot_data.get("short_term_memory") else 0
    num_known_users = len(users_data)
    num_ltm_facts = memory_manager.count_ltm_facts() if memory_manager else "–û—à–∏–±–∫–∞"
    
    num_emotional_records = 0
    if memory_manager and memory_manager.emotional_memory_handler:
        num_emotional_records = len(memory_manager.emotional_memory_handler.emotional_memory)

    stats_message = "üìä *–û—Ç—á–µ—Ç –æ —Å–æ—Å—Ç–æ—è–Ω–∏–∏ —Å–∏—Å—Ç–µ–º—ã –ø–∞–º—è—Ç–∏*\n\n"
    stats_message += f"   *–ò–∑–≤–µ—Å—Ç–Ω—ã–µ —Å—É–±—ä–µ–∫—Ç—ã:* {num_known_users} –µ–¥.\n"
    stats_message += f"   *–§–∞–∫—Ç—ã –≤ LTM:* {num_ltm_facts} –∑–∞–ø–∏—Å–µ–π\n"
    stats_message += f"   *–ó–∞–ø–∏—Å–µ–π –≤ STM (–±—É—Ñ–µ—Ä):* {short_term_memory_len} —Å–æ–æ–±—â–µ–Ω–∏–π\n"
    stats_message += f"   *–ó–∞–ø–∏—Å–∏ –≤ –≠–º–æ—Ü. –ü–∞–º—è—Ç–∏:* {num_emotional_records} —Å—É–±—ä–µ–∫—Ç–æ–≤\n"
    
    await update.message.reply_text(stats_message, parse_mode=constants.ParseMode.MARKDOWN)
    logger.info(f"–ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä {update.effective_user.full_name} –∑–∞–ø—Ä–æ—Å–∏–ª —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–∞–º—è—Ç–∏.")

async def list_facts_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id_str = str(update.effective_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await update.message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –±–æ—Ç–∞.")
        return

    memory_manager: MemoryManager = context.bot_data.get("memory_manager") 
    users_data: dict = context.bot_data.get("users_data_dict", {})
    if not memory_manager or not memory_manager.ltm_db or not memory_manager.ltm_db.collection:
        await update.message.reply_text("–î–æ–ª–≥–æ—Å—Ä–æ—á–Ω–∞—è –ø–∞–º—è—Ç—å (LTM) –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞.", parse_mode=constants.ParseMode.MARKDOWN)
        return

    try:
        all_facts_data = memory_manager.get_ltm_data(include=["metadatas"]) 
        
        if not all_facts_data or not all_facts_data.get("ids"):
            await update.message.reply_text("–í –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–π –ø–∞–º—è—Ç–∏ (LTM) –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –¥–∞–Ω–Ω—ã–µ.")
            return
            
        facts_for_sorting = []
        ids_list = all_facts_data.get("ids", []) 
        metadatas_list = all_facts_data.get("metadatas", [])

        for i in range(len(ids_list)):
            fact_id = ids_list[i]
            meta = metadatas_list[i] if i < len(metadatas_list) and metadatas_list[i] is not None else {}
            sort_key_timestamp = meta.get("last_accessed_timestamp", meta.get("timestamp_added", "1970-01-01T00:00:00Z"))
            facts_for_sorting.append({"id": fact_id, "sort_ts": sort_key_timestamp, "meta": meta})

        sorted_fact_items = sorted(facts_for_sorting, key=lambda x: x["sort_ts"], reverse=True)
        
        total_facts = len(sorted_fact_items)
        if total_facts == 0:
            await update.message.reply_text("–í –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–π –ø–∞–º—è—Ç–∏ (LTM) –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –¥–∞–Ω–Ω—ã–µ.")
            return

        total_pages = (total_facts + FACTS_PER_PAGE - 1) // FACTS_PER_PAGE
        current_page = 1

        context.user_data['sorted_ltm_fact_items'] = sorted_fact_items 
        context.user_data['ltm_facts_total_pages'] = total_pages
        
        page_content = await _format_facts_for_page(memory_manager, sorted_fact_items, current_page, users_data)
        
        header = f"üìö *–°–æ–¥–µ—Ä–∂–∏–º–æ–µ LTM (–°—Ç—Ä. {current_page}/{total_pages}, –í—Å–µ–≥–æ: {total_facts}, —Å–æ—Ä—Ç. –ø–æ –¥–æ—Å—Ç—É–ø—É/–¥–∞—Ç–µ):*"
        message_text = header + page_content
        reply_markup = _get_facts_pagination_keyboard(current_page, total_pages)
        
        await update.message.reply_text(message_text, reply_markup=reply_markup, parse_mode=constants.ParseMode.MARKDOWN)
        logger.info(f"–ê–¥–º–∏–Ω {update.effective_user.full_name} –∑–∞–ø—Ä–æ—Å–∏–ª LTM (–ø–∞–≥–∏–Ω–∞—Ü–∏—è). –°—Ç—Ä. {current_page}/{total_pages}")

    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –≤ list_facts_command: {e}", exc_info=True)
        await update.message.reply_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å–ø–∏—Å–∫–∞ —Ñ–∞–∫—Ç–æ–≤ LTM.")

async def facts_page_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query; await query.answer() 
    if query.data == "facts_page_ignore": return

    try: requested_page = int(query.data.split("_")[-1])
    except (ValueError, IndexError):
        logger.error(f"–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π callback_data –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ —Ñ–∞–∫—Ç–æ–≤: {query.data}")
        await query.edit_message_text("–û—à–∏–±–∫–∞: –Ω–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—Ç—Ä–∞–Ω–∏—Ü—ã.", parse_mode=constants.ParseMode.MARKDOWN); return

    user_id_str = str(query.from_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await query.edit_message_text("–≠—Ç–∞ —Ñ—É–Ω–∫—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.", parse_mode=constants.ParseMode.MARKDOWN); return

    memory_manager: MemoryManager = context.bot_data.get("memory_manager")
    users_data: dict = context.bot_data.get("users_data_dict", {})
        
    sorted_fact_items = context.user_data.get('sorted_ltm_fact_items') 
    total_pages = context.user_data.get('ltm_facts_total_pages') 

    if sorted_fact_items is None or total_pages is None:
        await query.edit_message_text("–û—à–∏–±–∫–∞: –î–∞–Ω–Ω—ã–µ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ —É—Å—Ç–∞—Ä–µ–ª–∏. –í—ã–ø–æ–ª–Ω–∏—Ç–µ /list_facts —Å–Ω–æ–≤–∞.", parse_mode=constants.ParseMode.MARKDOWN); return

    if not (1 <= requested_page <= total_pages):
        logger.warning(f"–ó–∞–ø—Ä–æ—à–µ–Ω–∞ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞ LTM {requested_page} –∏–∑ {total_pages}.")
        await query.answer("–ó–∞–ø—Ä–æ—à–µ–Ω–∞ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞."); return
        
    current_page = requested_page
    try:
        page_content = await _format_facts_for_page(memory_manager, sorted_fact_items, current_page, users_data)
        total_facts = len(sorted_fact_items)
        header = f"üìö *–°–æ–¥–µ—Ä–∂–∏–º–æ–µ LTM (–°—Ç—Ä. {current_page}/{total_pages}, –í—Å–µ–≥–æ: {total_facts}, —Å–æ—Ä—Ç. –ø–æ –¥–æ—Å—Ç—É–ø—É/–¥–∞—Ç–µ):*"
        message_text = header + page_content
        reply_markup = _get_facts_pagination_keyboard(current_page, total_pages)
        
        if query.message and (query.message.text != message_text or query.message.reply_markup != reply_markup) :
            await query.edit_message_text(text=message_text, reply_markup=reply_markup, parse_mode=constants.ParseMode.MARKDOWN)
        else: logger.info(f"–¢–µ–∫—Å—Ç –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä–∞ –¥–ª—è —Å—Ç—Ä–∞–Ω–∏—Ü—ã {current_page} LTM –Ω–µ –∏–∑–º–µ–Ω–∏–ª–∏—Å—å.")
        logger.info(f"–ê–¥–º–∏–Ω {query.from_user.full_name} –ø–µ—Ä–µ–∫–ª—é—á–∏–ª —Å—Ç—Ä–∞–Ω–∏—Ü—É LTM –Ω–∞ {current_page}/{total_pages}")
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã —Å–ø–∏—Å–∫–∞ LTM: {e}", exc_info=True)
        try: await query.edit_message_text("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç—Ä–∞–Ω–∏—Ü—ã LTM.", parse_mode=constants.ParseMode.MARKDOWN)
        except Exception: pass

async def find_facts_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id_str = str(update.effective_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id: await update.message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –±–æ—Ç–∞."); return
    if not context.args: await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `/find_facts <—Ç–µ–∫—Å—Ç–æ–≤—ã–π –∑–∞–ø—Ä–æ—Å>`", parse_mode=constants.ParseMode.MARKDOWN); return
    
    query_text = " ".join(context.args)
    memory_manager: MemoryManager = context.bot_data.get("memory_manager")
    if not memory_manager or not memory_manager.yandex_embedder or not memory_manager.ltm_db:
        await update.message.reply_text("–°–∏—Å—Ç–µ–º–∞ –ø–∞–º—è—Ç–∏ –∏–ª–∏ —ç–º–±–µ–¥–¥–µ—Ä –Ω–µ –≥–æ—Ç–æ–≤—ã –¥–ª—è –ø–æ–∏—Å–∫–∞.", parse_mode=constants.ParseMode.MARKDOWN); return
    
    max_relevant_distance = context.bot_data.get("LTM_MAX_RELEVANT_DISTANCE_CONFIG", 1.0)

    N_results = 5 
    found_fact_texts = await memory_manager.get_relevant_facts_from_ltm(
        query_text=query_text, 
        N=N_results,
        max_distance=max_relevant_distance
    )

    if not found_fact_texts:
        await update.message.reply_text(f"–°–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–∏–π –ø–æ–∏—Å–∫ –Ω–µ –¥–∞–ª —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –ø–æ –∑–∞–ø—Ä–æ—Å—É: '{escape_markdown(query_text)}' (–¥–∏—Å—Ç–∞–Ω—Ü–∏—è < {max_relevant_distance}).", parse_mode=constants.ParseMode.MARKDOWN); return

    response_text = f"üîé *–†–µ–∑—É–ª—å—Ç–∞—Ç—ã —Å–µ–º–∞–Ω—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–æ–∏—Å–∫–∞ –ø–æ –∑–∞–ø—Ä–æ—Å—É \"{escape_markdown(query_text)}\":*\n\n"
    for i, fact_text in enumerate(found_fact_texts):
        response_text += f"`{i+1}.` _{escape_markdown(fact_text)}_\n\n" 
    
    if len(response_text) > 4000: 
        await update.message.reply_text("–ù–∞–π–¥–µ–Ω–æ –º–Ω–æ–≥–æ, –ø–æ–∫–∞–∑—ã–≤–∞—é –ø–µ—Ä–≤—ã–µ:\n" + response_text[:3900] + "\n...", parse_mode=constants.ParseMode.MARKDOWN)
    else:
        await update.message.reply_text(response_text, parse_mode=constants.ParseMode.MARKDOWN)
    logger.info(f"–ê–¥–º–∏–Ω {update.effective_user.full_name} –∏—Å–∫–∞–ª —Ñ–∞–∫—Ç—ã: '{query_text}'. –ù–∞–π–¥–µ–Ω–æ: {len(found_fact_texts)}")

async def delete_fact_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id_str = str(update.effective_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await update.message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –±–æ—Ç–∞."); return

    if not context.args or len(context.args) != 1:
        await update.message.reply_text("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ: `/delete_fact <ID_—Ñ–∞–∫—Ç–∞>`", parse_mode=constants.ParseMode.MARKDOWN); return

    fact_id_to_delete = context.args[0]
    memory_manager: MemoryManager = context.bot_data.get("memory_manager") 

    if not memory_manager or not memory_manager.ltm_db:
        await update.message.reply_text("–î–æ–ª–≥–æ—Å—Ä–æ—á–Ω–∞—è –ø–∞–º—è—Ç—å (LTM) –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞.", parse_mode=constants.ParseMode.MARKDOWN); return
    
    try:
        # <--- –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–û: –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ —Ñ–∞–∫—Ç–∞ –ø–µ—Ä–µ–¥ —É–¥–∞–ª–µ–Ω–∏–µ–º ---
        fact_data = memory_manager.get_ltm_data(ids=[fact_id_to_delete], include=["metadatas"])
        fact_text_to_delete = "N/A"
        if fact_data and fact_data.get("ids") and fact_data.get("metadatas") and fact_data["metadatas"][0]:
            fact_text_to_delete = fact_data["metadatas"][0].get("text_original", "N/A")
        elif not (fact_data and fact_data.get("ids")):
            await update.message.reply_text(f"–§–∞–∫—Ç —Å ID `{escape_markdown(fact_id_to_delete)}` –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ LTM.", parse_mode=constants.ParseMode.MARKDOWN); return

        success = memory_manager.delete_ltm_facts_by_ids(ids=[fact_id_to_delete])
        
        if success:
            if 'sorted_ltm_fact_items' in context.user_data: del context.user_data['sorted_ltm_fact_items']
            if 'ltm_facts_total_pages' in context.user_data: del context.user_data['ltm_facts_total_pages']
            await update.message.reply_text(f"‚úÖ *–§–∞–∫—Ç —É–¥–∞–ª–µ–Ω.*\nID: `{escape_markdown(fact_id_to_delete)}`\n–¢–µ–∫—Å—Ç: _{escape_markdown(fact_text_to_delete)}_\n\n–ö—ç—à –ø–∞–≥–∏–Ω–∞—Ü–∏–∏ —Å–±—Ä–æ—à–µ–Ω. –î–ª—è –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ `/list_facts`.", parse_mode=constants.ParseMode.MARKDOWN)
            logger.info(f"–ê–¥–º–∏–Ω {update.effective_user.full_name} —É–¥–∞–ª–∏–ª —Ñ–∞–∫—Ç ID: {fact_id_to_delete} –∏–∑ LTM.")
        else:
            await update.message.reply_text(f"‚ùå *–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è.* –ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Ñ–∞–∫—Ç ID `{escape_markdown(fact_id_to_delete)}`. –í–æ–∑–º–æ–∂–Ω–æ, –æ–Ω —É–∂–µ –±—ã–ª —É–¥–∞–ª–µ–Ω.", parse_mode=constants.ParseMode.MARKDOWN)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ñ–∞–∫—Ç–∞ ID {fact_id_to_delete} –∏–∑ LTM: {e}", exc_info=True)
        await update.message.reply_text(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ —Ñ–∞–∫—Ç–∞ –∏–∑ LTM: {e}")

async def clear_ltm_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id_str = str(update.effective_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await update.message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –±–æ—Ç–∞."); return

    keyboard = [[
        InlineKeyboardButton("üî¥ –ü–û–î–¢–í–ï–†–î–ò–¢–¨ –û–ß–ò–°–¢–ö–£ LTM", callback_data="confirm_clear_ltm_yes"),
        InlineKeyboardButton("üü¢ –û—Ç–º–µ–Ω–∞", callback_data="confirm_clear_ltm_no")
    ]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "‚ÄºÔ∏è *–ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –î–ï–ô–°–¢–í–ò–ï* ‚ÄºÔ∏è\n–í—ã —Å–æ–±–∏—Ä–∞–µ—Ç–µ—Å—å –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ—Ç–æ–∫–æ–ª –ø–æ–ª–Ω–æ–π –æ—á–∏—Å—Ç–∫–∏ –î–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–π –ü–∞–º—è—Ç–∏ (LTM).\n\n*–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ –∏ –ø—Ä–∏–≤–µ–¥–µ—Ç –∫ –ø–æ—Ç–µ—Ä–µ –≤—Å–µ—Ö —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö —Ñ–∞–∫—Ç–æ–≤.* –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –æ–ø–µ—Ä–∞—Ü–∏—é.",
        reply_markup=reply_markup, parse_mode=constants.ParseMode.MARKDOWN)
    logger.info(f"–ê–¥–º–∏–Ω {update.effective_user.full_name} –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞–ª –æ—á–∏—Å—Ç–∫—É –í–°–ï–• —Ñ–∞–∫—Ç–æ–≤ LTM.")

async def confirm_clear_ltm_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query; await query.answer()
    user_id_str = str(query.from_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await query.edit_message_text("–û–ø–µ—Ä–∞—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.", parse_mode=constants.ParseMode.MARKDOWN); return

    choice = query.data
    memory_manager: MemoryManager = context.bot_data.get("memory_manager")

    if choice == "confirm_clear_ltm_yes":
        if not memory_manager or not memory_manager.ltm_db: 
            await query.edit_message_text("–û—à–∏–±–∫–∞: LTM –∫–æ–º–ø–æ–Ω–µ–Ω—Ç –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.", parse_mode=constants.ParseMode.MARKDOWN); return
        try:
            logger.warning(f"–ê–¥–º–∏–Ω {query.from_user.full_name} –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª –æ—á–∏—Å—Ç–∫—É –í–°–ï–• —Ñ–∞–∫—Ç–æ–≤ LTM.")
            success = memory_manager.clear_all_ltm_facts()
            if success:
                if 'sorted_ltm_fact_items' in context.user_data: del context.user_data['sorted_ltm_fact_items']
                if 'ltm_facts_total_pages' in context.user_data: del context.user_data['ltm_facts_total_pages']
                await query.edit_message_text("‚úÖ *–ü—Ä–æ—Ç–æ–∫–æ–ª –≤—ã–ø–æ–ª–Ω–µ–Ω.* –î–æ–ª–≥–æ—Å—Ä–æ—á–Ω–∞—è –ü–∞–º—è—Ç—å (LTM) –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—â–µ–Ω–∞.", parse_mode=constants.ParseMode.MARKDOWN)
                logger.warning(f"LTM —Ñ–∞–∫—Ç—ã –æ—á–∏—â–µ–Ω—ã –∞–¥–º–∏–Ω–æ–º {query.from_user.full_name}.")
            else:
                await query.edit_message_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—Å—Ç–∏—Ç—å LTM —Ñ–∞–∫—Ç—ã. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏.", parse_mode=constants.ParseMode.MARKDOWN)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª–Ω–æ–π –æ—á–∏—Å—Ç–∫–µ LTM —Ñ–∞–∫—Ç–æ–≤: {e}", exc_info=True)
            await query.edit_message_text(f"‚ùå –û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ LTM —Ñ–∞–∫—Ç–æ–≤: {escape_markdown(str(e))}", parse_mode=constants.ParseMode.MARKDOWN)
    elif choice == "confirm_clear_ltm_no":
        await query.edit_message_text("üëå *–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.* –û—á–∏—Å—Ç–∫–∞ LTM –Ω–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏–ª–∞—Å—å.", parse_mode=constants.ParseMode.MARKDOWN)
        logger.info(f"–ê–¥–º–∏–Ω {query.from_user.full_name} –æ—Ç–º–µ–Ω–∏–ª –æ—á–∏—Å—Ç–∫—É LTM —Ñ–∞–∫—Ç–æ–≤.")

async def clear_emotional_user_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id_str = str(update.effective_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await update.message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –±–æ—Ç–∞.")
        return

    if not context.args:
        await update.message.reply_text(
            "–£–∫–∞–∂–∏—Ç–µ ID, –∏–º—è –∏–ª–∏ –Ω–∏–∫ —Å—É–±—ä–µ–∫—Ç–∞, —á—å—é —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω—É—é –ø–∞–º—è—Ç—å (EM) –Ω—É–∂–Ω–æ –æ—á–∏—Å—Ç–∏—Ç—å.\n"
            "–ü—Ä–∏–º–µ—Ä: `/clear_emo_user 123456789`",
            parse_mode=constants.ParseMode.MARKDOWN
        )
        return

    query_arg = " ".join(context.args).strip()
    users_data: dict = context.bot_data.get("users_data_dict", {})
    memory_manager: MemoryManager = context.bot_data.get("memory_manager")

    if not memory_manager or not memory_manager.emotional_memory_handler:
        await update.message.reply_text("–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.")
        return

    found_user_id_to_clear = None
    found_user_name_to_clear = "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å—É–±—ä–µ–∫—Ç"

    for u_id, info in users_data.items():
        name_lower = info.get('name', '').lower()
        nicknames = info.get('nicknames', [])
        if isinstance(nicknames, str): nicknames = [nicknames]
        nicknames_lower = [nick.lower() for nick in nicknames]

        if query_arg == u_id or query_arg.lower() == name_lower or query_arg.lower() in nicknames_lower:
            found_user_id_to_clear = u_id
            found_user_name_to_clear = info.get('name', f"User_{u_id}")
            break
    
    # <--- –í–û–°–°–¢–ê–ù–û–í–õ–ï–ù–û: –ü–æ–∏—Å–∫ –ø–æ ID –≤ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏, –µ—Å–ª–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ users.json ---
    if not found_user_id_to_clear and query_arg.isdigit():
        emo_data_exists = memory_manager.get_emotional_notes(query_arg)
        if emo_data_exists:
             found_user_id_to_clear = query_arg
             found_user_name_to_clear = emo_data_exists.get("name", f"User_{query_arg}")
        
    if not found_user_id_to_clear:
        await update.message.reply_text(f"–°—É–±—ä–µ–∫—Ç –ø–æ –∑–∞–ø—Ä–æ—Å—É '{escape_markdown(query_arg)}' –Ω–µ –Ω–∞–π–¥–µ–Ω.")
        return

    keyboard = [[
        InlineKeyboardButton(f"üóëÔ∏è –î–∞, –æ—á–∏—Å—Ç–∏—Ç—å –¥–ª—è {escape_markdown(found_user_name_to_clear)}", callback_data=f"confirm_clear_emo_user_yes_{found_user_id_to_clear}"),
        InlineKeyboardButton("üü¢ –ù–µ—Ç, –æ—Ç–º–µ–Ω–∞", callback_data=f"confirm_clear_emo_user_no_{found_user_id_to_clear}")
    ]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        f"–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç–µ –æ—á–∏—Å—Ç–∫—É –≤—Å–µ–π —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏ –¥–ª—è —Å—É–±—ä–µ–∫—Ç–∞ *{escape_markdown(found_user_name_to_clear)}* (ID: `{found_user_id_to_clear}`).\n"
        f"–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ.",
        reply_markup=reply_markup,
        parse_mode=constants.ParseMode.MARKDOWN
    )
    logger.info(f"–ê–¥–º–∏–Ω {update.effective_user.full_name} –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞–ª –æ—á–∏—Å—Ç–∫—É EM –¥–ª—è ID: {found_user_id_to_clear}.")

async def confirm_clear_emotional_user_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    requesting_admin_id_str = str(query.from_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or requesting_admin_id_str != admin_user_id:
        await query.edit_message_text("–û–ø–µ—Ä–∞—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
        return

    callback_data_parts = query.data.split("_") 
    action = callback_data_parts[-2] 
    user_id_to_clear = callback_data_parts[-1]

    memory_manager: MemoryManager = context.bot_data.get("memory_manager")
    if not memory_manager or not memory_manager.emotional_memory_handler:
        await query.edit_message_text("–û—à–∏–±–∫–∞: –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.")
        return
    
    user_name_display = f"User_{user_id_to_clear}"
    user_data_entry = context.bot_data.get("users_data_dict", {}).get(user_id_to_clear)
    if user_data_entry and user_data_entry.get("name"):
        user_name_display = user_data_entry.get("name")
    else:
        emo_note = memory_manager.get_emotional_notes(user_id_to_clear)
        if emo_note and emo_note.get("name"):
            user_name_display = emo_note.get("name")

    if action == "yes":
        success = memory_manager.clear_user_emotional_data(user_id_to_clear)
        if success:
            await query.edit_message_text(f"‚úÖ *–û–ø–µ—Ä–∞—Ü–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∞.* –≠–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –ø–∞–º—è—Ç—å –¥–ª—è *{escape_markdown(user_name_display)}* –æ—á–∏—â–µ–Ω–∞.", parse_mode=constants.ParseMode.MARKDOWN)
        else:
            await query.edit_message_text(f"‚ùå *–û—à–∏–±–∫–∞.* –ù–µ —É–¥–∞–ª–æ—Å—å –æ—á–∏—Å—Ç–∏—Ç—å EM –¥–ª—è *{escape_markdown(user_name_display)}*.", parse_mode=constants.ParseMode.MARKDOWN)
    elif action == "no":
        await query.edit_message_text(f"üëå *–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.* EM –¥–ª—è *{escape_markdown(user_name_display)}* –Ω–µ –∑–∞—Ç—Ä–æ–Ω—É—Ç–∞.", parse_mode=constants.ParseMode.MARKDOWN)
    else:
        await query.edit_message_text("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –≤—ã–±–æ—Ä.")

async def clear_emotional_all_danger_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id_str = str(update.effective_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await update.message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –±–æ—Ç–∞.")
        return

    keyboard = [[
        InlineKeyboardButton("üî¥ –ü–û–î–¢–í–ï–†–î–ò–¢–¨ –û–ß–ò–°–¢–ö–£ –í–°–ï–ô EM", callback_data="confirm_clear_emo_all_yes"),
        InlineKeyboardButton("üü¢ –û—Ç–º–µ–Ω–∞", callback_data="confirm_clear_emo_all_no")
    ]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "‚ÄºÔ∏è *–ö–†–ò–¢–ò–ß–ï–°–ö–û–ï –î–ï–ô–°–¢–í–ò–ï* ‚ÄºÔ∏è\n–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ *–ü–û–õ–ù–û–°–¢–¨–Æ –û–ß–ò–°–¢–ò–¢–¨ –í–°–Æ –≠–ú–û–¶–ò–û–ù–ê–õ–¨–ù–£–Æ –ü–ê–ú–Ø–¢–¨* (–¥–ª—è –≤—Å–µ—Ö —Å—É–±—ä–µ–∫—Ç–æ–≤)?\n"
        "*–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –ù–ï–û–ë–†–ê–¢–ò–ú–û!*",
        reply_markup=reply_markup,
        parse_mode=constants.ParseMode.MARKDOWN
    )
    logger.info(f"–ê–¥–º–∏–Ω {update.effective_user.full_name} –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞–ª –æ—á–∏—Å—Ç–∫—É –í–°–ï–ô EM.")

async def confirm_clear_emotional_all_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()

    requesting_admin_id_str = str(query.from_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or requesting_admin_id_str != admin_user_id:
        await query.edit_message_text("–û–ø–µ—Ä–∞—Ü–∏—è –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.")
        return

    choice = query.data 
    memory_manager: MemoryManager = context.bot_data.get("memory_manager")

    if not memory_manager or not memory_manager.emotional_memory_handler:
        await query.edit_message_text("–û—à–∏–±–∫–∞: –û–±—Ä–∞–±–æ—Ç—á–∏–∫ —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–æ–π –ø–∞–º—è—Ç–∏ –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω.")
        return

    if choice == "confirm_clear_emo_all_yes":
        try:
            logger.warning(f"–ê–¥–º–∏–Ω {query.from_user.full_name} –ø–æ–¥—Ç–≤–µ—Ä–¥–∏–ª –æ—á–∏—Å—Ç–∫—É –í–°–ï–ô EM.")
            success = memory_manager.clear_all_emotional_data()
            if success:
                await query.edit_message_text("‚úÖ *–ü—Ä–æ—Ç–æ–∫–æ–ª –≤—ã–ø–æ–ª–Ω–µ–Ω.* –í—Å—è —ç–º–æ—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è –ø–∞–º—è—Ç—å (EM) –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—â–µ–Ω–∞.", parse_mode=constants.ParseMode.MARKDOWN)
            else:
                await query.edit_message_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª–Ω–æ—Å—Ç—å—é –æ—á–∏—Å—Ç–∏—Ç—å –≤—Å—é EM. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏.", parse_mode=constants.ParseMode.MARKDOWN)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª–Ω–æ–π –æ—á–∏—Å—Ç–∫–µ –≤—Å–µ–π EM: {e}", exc_info=True)
            await query.edit_message_text(f"‚ùå –û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –≤—Å–µ–π EM: {escape_markdown(str(e))}", parse_mode=constants.ParseMode.MARKDOWN)
    elif choice == "confirm_clear_emo_all_no":
        await query.edit_message_text("üëå *–û–ø–µ—Ä–∞—Ü–∏—è –æ—Ç–º–µ–Ω–µ–Ω–∞.* –û—á–∏—Å—Ç–∫–∞ –≤—Å–µ–π EM –Ω–µ –ø—Ä–æ–∏–∑–≤–æ–¥–∏–ª–∞—Å—å.", parse_mode=constants.ParseMode.MARKDOWN)
    else:
        await query.edit_message_text("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –≤—ã–±–æ—Ä.")

async def maintain_ltm_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id_str = str(update.effective_user.id)
    admin_user_id = context.bot_data.get("admin_user_id")
    if not admin_user_id or user_id_str != admin_user_id:
        await update.message.reply_text("–≠—Ç–∞ –∫–æ–º–∞–Ω–¥–∞ –¥–æ—Å—Ç—É–ø–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É –±–æ—Ç–∞.")
        return

    memory_manager: MemoryManager = context.bot_data.get("memory_manager")
    if not memory_manager or not memory_manager.ltm_db or not memory_manager.yandex_embedder:
        await update.message.reply_text("LTM –∏–ª–∏ —ç–º–±–µ–¥–¥–µ—Ä –Ω–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω—ã. –û–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–µ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ.")
        return

    await update.message.reply_text("‚è≥ *–ó–∞–ø—É—Å–∫ –ø—Ä–æ—Ç–æ–∫–æ–ª–∞ –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è LTM...*\n–ê–Ω–∞–ª–∏–∑ –∏ –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö. –û—Ç—á–µ—Ç –±—É–¥–µ—Ç –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω –ø–æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏.", 
                                    parse_mode=constants.ParseMode.MARKDOWN)
    
    try:
        args = context.args
        maintenance_config = {
            "similarity_threshold": float(args[0]) if args and len(args) > 0 else 0.95,
            "max_days_unaccessed": int(args[1]) if args and len(args) > 1 else 90,
            "min_access_for_retention": int(args[2]) if args and len(args) > 2 else 1,
            "importance_decay_factor": context.bot_data.get("LTM_IMPORTANCE_DECAY_FACTOR_CONFIG", 0.02),
            "min_importance_for_retention": context.bot_data.get("LTM_MIN_IMPORTANCE_FOR_RETENTION_CONFIG", 0.5),
            "days_for_decay_check": context.bot_data.get("LTM_DAYS_FOR_IMPORTANCE_DECAY_CONFIG", 14)
        }
        
        logger.info(f"–ê–¥–º–∏–Ω {update.effective_user.full_name} –∑–∞–ø—É—Å—Ç–∏–ª –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–µ LTM —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏: {maintenance_config}")
        
        results = await memory_manager.perform_ltm_maintenance(maintenance_config)

        if results.get("error"):
            await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞ –≤–æ –≤—Ä–µ–º—è –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è LTM: {results['error']}")
            return
            
        if results.get("total_deleted", 0) > 0 or results.get("updated_importance", 0) > 0:
            if 'sorted_ltm_fact_items' in context.user_data: del context.user_data['sorted_ltm_fact_items']
            if 'ltm_facts_total_pages' in context.user_data: del context.user_data['ltm_facts_total_pages']

        deleted_duplicates = results.get("deleted_duplicates", 0)
        deleted_obsolete = results.get("deleted_obsolete", 0)
        total_deleted = results.get("total_deleted", 0)
        updated_importance = results.get("updated_importance", 0)

        if total_deleted == 0 and updated_importance == 0:
            await update.message.reply_text("‚úÖ *–û–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–µ LTM –∑–∞–≤–µ—Ä—à–µ–Ω–æ.* –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è –Ω–µ –ø–æ—Ç—Ä–µ–±–æ–≤–∞–ª–∞—Å—å, –¥–∞–Ω–Ω—ã–µ –≤ –∞–∫—Ç—É–∞–ª—å–Ω–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏.", parse_mode=constants.ParseMode.MARKDOWN)
        else:
            await update.message.reply_text(
                f"‚úÖ *–û–±—Å–ª—É–∂–∏–≤–∞–Ω–∏–µ LTM –∑–∞–≤–µ—Ä—à–µ–Ω–æ.*\n\n"
                f"   *–û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è:*\n"
                f"   - –£—Å—Ç—Ä–∞–Ω–µ–Ω–æ –¥—É–±–ª–∏–∫–∞—Ç–æ–≤/—Å—Ö–æ–∂–∏—Ö: {deleted_duplicates}\n"
                f"   - –£–¥–∞–ª–µ–Ω–æ —É—Å—Ç–∞—Ä–µ–≤—à–∏—Ö/–Ω–µ–≤–∞–∂–Ω—ã—Ö: {deleted_obsolete}\n"
                f"   - *–í—Å–µ–≥–æ –∑–∞–ø–∏—Å–µ–π —É–¥–∞–ª–µ–Ω–æ:* {total_deleted}\n"
                f"   - *–ü–µ—Ä–µ—Å—á–∏—Ç–∞–Ω–∞ –≤–∞–∂–Ω–æ—Å—Ç—å (decay):* {updated_importance} —Ñ–∞–∫—Ç–æ–≤.",
                parse_mode=constants.ParseMode.MARKDOWN
            )

    except Exception as e:
        logger.error(f"–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ —Ö–µ–Ω–¥–ª–µ—Ä–µ maintain_ltm_command: {e}", exc_info=True)
        await update.message.reply_text(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –≤ —Ö–µ–Ω–¥–ª–µ—Ä–µ /maintain_ltm: {escape_markdown(str(e))}", parse_mode=constants.ParseMode.MARKDOWN)